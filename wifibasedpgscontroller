//EXAMPLE-1 zone1 controller which receive the request command through the floor controller through wireless using espnow. and when it recive the request then it send the request to the sensors and capture the response from then. and after that 
// it will send the display data and the floor data worelessly using espnow
from machine import UART, Pin
import time
import espnow
import network

# Initialize UARTs
uart1 = UART(1, baudrate=9600, tx=Pin(16), rx=Pin(17))

# Initialize ESP-NOW
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
esp_now = espnow.ESPNow()
esp_now.init()

# Register peers (Floor Controller and Display Controller MAC addresses)
floor_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the floor controller
display_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the display controller
esp_now.add_peer(floor_controller_mac)
esp_now.add_peer(display_controller_mac)

sensor_requests = ['FA0101F9', 'FA0201FA', 'FA0301FB']
zone_id = b'\x01'  # Change this for each zone controller (e.g., b'\x02' for zone 2)

def crc16(data: bytearray) -> int:
    crc = 0x0000
    for byte in data:
        crc ^= byte << 8
        for _ in range(8):
            if (crc & 0x8000) != 0:
                crc = (crc << 1) ^ 0x1021
            else:
                crc = crc << 1
        crc &= 0xFFFF  # Ensure CRC remains 16-bit
    return crc

def calculate_sensor_status(response):
    status_byte = response[2:3]
    if status_byte == b'\x01':
        return 1  # Engaged
    elif status_byte == b'\x02':
        return 2  # Disengaged
    elif status_byte == b'\x03':
        return 3  # Error
    else:
        return -1  # Invalid status

def process_sensor_requests():
    sensor_status = []

    for request in sensor_requests:
        if request.startswith('FA'):
            uart1.write(bytes.fromhex(request))
            time.sleep(0.1)
            response = uart1.read()
            if response and response[0:1] == b'\xF5':
                sensor_status.append(calculate_sensor_status(response))
            else:
                sensor_status.append(0)
    # Construct message
    total_sensors = len(sensor_requests)
    total_engaged = sensor_status.count(1)
    total_disengaged = sensor_status.count(2)
    total_errors = sensor_status.count(3)
    total_vacancy = total_disengaged
    message = bytearray([0xAA, int.from_bytes(zone_id, "little"), total_sensors] + sensor_status + [total_engaged, total_disengaged, total_vacancy, total_errors])
    
    # Calculate CRC-16
    crc = crc16(message)
    message.append(crc >> 8)  # Append high byte of CRC
    message.append(crc & 0xFF)  # Append low byte of CRC
    message.append(0x55)
    
    # Send message using ESP-NOW to Floor Controller
    esp_now.send(floor_controller_mac, message)
    
    # Display part
    slots_str = f'{total_vacancy:02d}'
    display_message = f'|C|1|4|1|28-0-#u{slots_str}|'
    print(display_message)
    
    # Send display message using ESP-NOW to Display Controller
    esp_now.send(display_controller_mac, display_message.encode())

# Listen for commands from the floor controller
def on_receive_msg(peer, msg):
    if len(msg) == 5 and msg[0:1] == b'\xAA' and msg[4:5] == b'\x55':
        command_zone_id = msg[1:2]
        if command_zone_id == zone_id:
            process_sensor_requests()

esp_now.on_recv(on_receive_msg)

while True:
    time.sleep(1)

//EXAMPLE-2 zone1 controller which receive the request command through the floor controller through wireless using espnow. and when it recive the request then it send the request to the sensors and capture the response from then. and after that 
// it will send the display data and the floor data worelessly using espnow
from machine import UART, Pin
import time
import espnow
import network

# Initialize UARTs
uart1 = UART(1, baudrate=9600, tx=Pin(16), rx=Pin(17))

# Initialize ESP-NOW
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
esp_now = espnow.ESPNow()
esp_now.init()

# Register peers (Floor Controller and Display Controller MAC addresses)
floor_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the floor controller
display_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the display controller
esp_now.add_peer(floor_controller_mac)
esp_now.add_peer(display_controller_mac)

sensor_requests = ['FA0101F9', 'FA0201FA', 'FA0301FB']
zone_id = b'\x02'  # Change this for each zone controller (e.g., b'\x02' for zone 2)

def crc16(data: bytearray) -> int:
    crc = 0x0000
    for byte in data:
        crc ^= byte << 8
        for _ in range(8):
            if (crc & 0x8000) != 0:
                crc = (crc << 1) ^ 0x1021
            else:
                crc = crc << 1
        crc &= 0xFFFF  # Ensure CRC remains 16-bit
    return crc

def calculate_sensor_status(response):
    status_byte = response[2:3]
    if status_byte == b'\x01':
        return 1  # Engaged
    elif status_byte == b'\x02':
        return 2  # Disengaged
    elif status_byte == b'\x03':
        return 3  # Error
    else:
        return -1  # Invalid status

def process_sensor_requests():
    sensor_status = []

    for request in sensor_requests:
        if request.startswith('FA'):
            uart1.write(bytes.fromhex(request))
            time.sleep(0.1)
            response = uart1.read()
            if response and response[0:1] == b'\xF5':
                sensor_status.append(calculate_sensor_status(response))
            else:
                sensor_status.append(0)
    # Construct message
    total_sensors = len(sensor_requests)
    total_engaged = sensor_status.count(1)
    total_disengaged = sensor_status.count(2)
    total_errors = sensor_status.count(3)
    total_vacancy = total_disengaged
    message = bytearray([0xAA, int.from_bytes(zone_id, "little"), total_sensors] + sensor_status + [total_engaged, total_disengaged, total_vacancy, total_errors])
    
    # Calculate CRC-16
    crc = crc16(message)
    message.append(crc >> 8)  # Append high byte of CRC
    message.append(crc & 0xFF)  # Append low byte of CRC
    message.append(0x55)
    
    # Send message using ESP-NOW to Floor Controller
    esp_now.send(floor_controller_mac, message)
    
    # Display part
    slots_str = f'{total_vacancy:02d}'
    display_message = f'|C|1|4|1|28-0-#u{slots_str}|'
    print(display_message)
    
    # Send display message using ESP-NOW to Display Controller
    esp_now.send(display_controller_mac, display_message.encode())

# Listen for commands from the floor controller
def on_receive_msg(peer, msg):
    if len(msg) == 5 and msg[0:1] == b'\xAA' and msg[4:5] == b'\x55':
        command_zone_id = msg[1:2]
        if command_zone_id == zone_id:
            process_sensor_requests()

esp_now.on_recv(on_receive_msg)

while True:
    time.sleep(1)

//EXAMPLE-3 zone1 controller which receive the request command through the floor controller through wireless using espnow. and when it recive the request then it send the request to the sensors and capture the response from then. and after that 
// it will send the display data and the floor data worelessly using espnow
from machine import UART, Pin
import time
import espnow
import network

# Initialize UARTs
uart1 = UART(1, baudrate=9600, tx=Pin(16), rx=Pin(17))

# Initialize ESP-NOW
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
esp_now = espnow.ESPNow()
esp_now.init()

# Register peers (Floor Controller and Display Controller MAC addresses)
floor_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the floor controller
display_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the display controller
esp_now.add_peer(floor_controller_mac)
esp_now.add_peer(display_controller_mac)

sensor_requests = ['FA0101F9', 'FA0201FA', 'FA0301FB']
zone_id = b'\x03'  # Change this for each zone controller (e.g., b'\x02' for zone 2)

def crc16(data: bytearray) -> int:
    crc = 0x0000
    for byte in data:
        crc ^= byte << 8
        for _ in range(8):
            if (crc & 0x8000) != 0:
                crc = (crc << 1) ^ 0x1021
            else:
                crc = crc << 1
        crc &= 0xFFFF  # Ensure CRC remains 16-bit
    return crc

def calculate_sensor_status(response):
    status_byte = response[2:3]
    if status_byte == b'\x01':
        return 1  # Engaged
    elif status_byte == b'\x02':
        return 2  # Disengaged
    elif status_byte == b'\x03':
        return 3  # Error
    else:
        return -1  # Invalid status

def process_sensor_requests():
    sensor_status = []

    for request in sensor_requests:
        if request.startswith('FA'):
            uart1.write(bytes.fromhex(request))
            time.sleep(0.1)
            response = uart1.read()
            if response and response[0:1] == b'\xF5':
                sensor_status.append(calculate_sensor_status(response))
            else:
                sensor_status.append(0)
    # Construct message
    total_sensors = len(sensor_requests)
    total_engaged = sensor_status.count(1)
    total_disengaged = sensor_status.count(2)
    total_errors = sensor_status.count(3)
    total_vacancy = total_disengaged
    message = bytearray([0xAA, int.from_bytes(zone_id, "little"), total_sensors] + sensor_status + [total_engaged, total_disengaged, total_vacancy, total_errors])
    
    # Calculate CRC-16
    crc = crc16(message)
    message.append(crc >> 8)  # Append high byte of CRC
    message.append(crc & 0xFF)  # Append low byte of CRC
    message.append(0x55)
    
    # Send message using ESP-NOW to Floor Controller
    esp_now.send(floor_controller_mac, message)
    
    # Display part
    slots_str = f'{total_vacancy:02d}'
    display_message = f'|C|1|4|1|28-0-#u{slots_str}|'
    print(display_message)
    
    # Send display message using ESP-NOW to Display Controller
    esp_now.send(display_controller_mac, display_message.encode())

# Listen for commands from the floor controller
def on_receive_msg(peer, msg):
    if len(msg) == 5 and msg[0:1] == b'\xAA' and msg[4:5] == b'\x55':
        command_zone_id = msg[1:2]
        if command_zone_id == zone_id:
            process_sensor_requests()

esp_now.on_recv(on_receive_msg)

while True:
    time.sleep(1)

//EXAMPLE-4 Floor controller using esp32
import time
import espnow
import network

# Initialize ESP-NOW
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
esp_now = espnow.ESPNow()
esp_now.init()

# Register peers (Zone Controllers and Master Controller MAC addresses)
zone_controller_macs = [
    b'\xFF\xFF\xFF\xFF\xFF\xFF',  # Replace with actual MAC address of zone controller 1
    b'\xFF\xFF\xFF\xFF\xFF\xFF',  # Replace with actual MAC address of zone controller 2
    b'\xFF\xFF\xFF\xFF\xFF\xFF'   # Replace with actual MAC address of zone controller 3
]
master_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the master controller

# Add peers for ESP-NOW
for mac in zone_controller_macs:
    esp_now.add_peer(mac)
esp_now.add_peer(master_controller_mac)

slave_ids = [b'\x01', b'\x02', b'\x03']
num_zones = len(slave_ids)
floor_id = b'\x01'

def crc16(data: bytearray) -> int:
    """Calculate the CRC-16 of a data bytearray."""
    crc = 0x0000
    for byte in data:
        crc ^= byte << 8
        for _ in range(8):
            if (crc & 0x8000) != 0:
                crc = (crc << 1) ^ 0x1021
            else:
                crc = crc << 1
        crc &= 0xFFFF  # Ensure CRC remains 16-bit
    return crc

def verify_crc(data: bytearray) -> bool:
    """Verify the CRC of a data bytearray."""
    if len(data) < 3:
        return False
    received_crc = (data[-3] << 8) | data[-2]
    calculated_crc = crc16(data[:-3])
    return received_crc == calculated_crc

def create_request(slave_id):
    """Create a request packet for a given slave ID."""
    request = bytearray([0xAA, slave_id[0], 0x80, 0xA0, 0x55])
    return request

def collect_data_from_slave(slave_id, slave_mac):
    """Collect data from a specified slave controller."""
    request = create_request(slave_id)
    esp_now.send(slave_mac, request)
    print("Request sent to Slave", slave_id.hex())
    time.sleep(0.5)

    response = bytearray()
    start_time = time.time()
    while time.time() - start_time < 4:
        if esp_now.any() > 0:
            peer, msg = esp_now.recv()
            if msg and msg[-1:] == b'\x55' and len(msg) >= 12:  # Adjust length for CRC
                response = msg
                break

    if response:
        print("Raw response from Slave", slave_id.hex(), ":", response.hex())
        if response[0:1] == b'\xAA' and response[1:2] == slave_id and response[-1:] == b'\x55' and verify_crc(response):
            print("Valid response from Slave", slave_id.hex(), ":", response.hex())
            return response
        else:
            print("Invalid or incomplete response from Slave", slave_id.hex(), ":", response.hex())
    else:
        print("No response from Slave", slave_id.hex())

    return None

def collect_data_from_slaves():
    """Collect data from all slave controllers and send the consolidated message."""
    all_zone_data = []
    total_engaged = 0
    total_disengaged = 0
    total_vacancy = 0
    total_errors = 0

    for slave_id, slave_mac in zip(slave_ids, zone_controller_macs):
        print("Collecting data from Slave", slave_id.hex())
        response = collect_data_from_slave(slave_id, slave_mac)
        time.sleep(0.5)
        if response:
            all_zone_data.append(response)
            if len(response) >= 12:
                total_engaged += response[-7]
                total_disengaged += response[-6]
                total_vacancy += response[-5]
                total_errors += response[-4]

    # Construct the final message
    message = bytearray([0xDE, 0x01, num_zones])
    for zone_data in all_zone_data:
        message.extend(zone_data)

    total_data = bytearray([total_engaged, total_disengaged, total_vacancy, total_errors, 0xE9])
    message.extend(total_data)
    hex_message_with_spaces = ' '.join('{:02x}'.format(byte) for byte in message)
    print(f"Hex message with spaces: {hex_message_with_spaces.upper()}")
    esp_now.send(master_controller_mac, message)

# Callback function to handle received messages
def on_receive_msg(peer, msg):
    if len(msg) == 5 and msg == bytearray([0xAA, floor_id[0], 0x80, 0xA0, 0x55]):
        print("Valid request received from master:", msg.hex())
        collect_data_from_slaves()
    else:
        print("Invalid request received:", msg.hex())

# Register callback for received ESP-NOW messages
esp_now.on_recv(on_receive_msg)

while True:
    time.sleep(1)

//EXAMPLE-5 Master controller
import espnow
import network
import time

# Initialize ESP-NOW
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
esp_now = espnow.ESPNow()
esp_now.init()

# Define floor IDs and their MAC addresses
floor_ids = [0x01, 0x02, 0x03]  # Using integers directly for floor IDs
floor_controller_macs = [
    b'\xFF\xFF\xFF\xFF\xFF\xFF',  # Replace with actual MAC address of floor controller 1
    b'\xFF\xFF\xFF\xFF\xFF\xFF',  # Replace with actual MAC address of floor controller 2
    b'\xFF\xFF\xFF\xFF\xFF\xFF'   # Replace with actual MAC address of floor controller 3
]
master_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the master controller

# Add peers for ESP-NOW
for mac in floor_controller_macs:
    esp_now.add_peer(mac)
esp_now.add_peer(master_controller_mac)

num_floors = len(floor_ids)

# Function to send request byte to floor controller
def send_request_to_floor(floor_id, floor_mac):
    request_byte = bytearray([0xAA, floor_id, 0x80, 0xA0, 0x55])
    esp_now.send(floor_mac, request_byte)

# Function to collect data from a single floor
def collect_data_from_floor(floor_id, floor_mac):
    send_request_to_floor(floor_id, floor_mac)

    response = bytearray()
    start_time = time.time()
    while True:
        if esp_now.any():
            peer, msg = esp_now.recv()
            if peer == floor_mac:
                response.extend(msg)
                # Check for start and end of frame markers
                if response[:1] == b'\xDE' and response[-1:] == b'\xE9':
                    break
        if time.time() - start_time > 10:
            break

    if response:
        return response  # Return the complete response including end marker
    return None

# Function to collect and process data from all floors
def collect_data_from_floors():
    all_floor_data = []
    total_engaged = 0
    total_disengaged = 0
    total_vacancy = 0
    total_errors = 0

    for floor_id, floor_mac in zip(floor_ids, floor_controller_macs):
        response = collect_data_from_floor(floor_id, floor_mac)
        time.sleep(0.1)
        if response:
            all_floor_data.append(response)
            if len(response) >= 12:
                total_engaged += response[-5]
                total_disengaged += response[-4]
                total_vacancy += response[-3]
                total_errors += response[-2]

    # Build the final message
    message = bytearray([0xF4, 0x01, num_floors])
    for floor_data in all_floor_data:
        message.extend(floor_data)

    total_data = bytearray([total_engaged, total_disengaged, total_vacancy, total_errors, 0xD1])
    message.extend(total_data)

    hex_message_with_spaces = ' '.join('{:02x}'.format(byte) for byte in message)
    print(f"Master Data with spaces: {hex_message_with_spaces.upper()}")
    esp_now.send(master_controller_mac, message)

# Main loop to collect data periodically
while True:
    collect_data_from_floors()
    time.sleep(1)

