//EXAMPLE-1 zone1 controller which receive the request command through the floor controller through wireless using espnow. and when it recive the request then it send the request to the sensors and capture the response from then. and after that 
// it will send the display data and the floor data worelessly using espnow
from machine import UART, Pin
import time
import espnow
import network

# Initialize UARTs
uart1 = UART(1, baudrate=9600, tx=Pin(16), rx=Pin(17))

# Initialize ESP-NOW
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
esp_now = espnow.ESPNow()
esp_now.init()

# Register peers (Floor Controller and Display Controller MAC addresses)
floor_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the floor controller
display_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the display controller
esp_now.add_peer(floor_controller_mac)
esp_now.add_peer(display_controller_mac)

sensor_requests = ['FA0101F9', 'FA0201FA', 'FA0301FB']
zone_id = b'\x01'  # Change this for each zone controller (e.g., b'\x02' for zone 2)

def crc16(data: bytearray) -> int:
    crc = 0x0000
    for byte in data:
        crc ^= byte << 8
        for _ in range(8):
            if (crc & 0x8000) != 0:
                crc = (crc << 1) ^ 0x1021
            else:
                crc = crc << 1
        crc &= 0xFFFF  # Ensure CRC remains 16-bit
    return crc

def calculate_sensor_status(response):
    status_byte = response[2:3]
    if status_byte == b'\x01':
        return 1  # Engaged
    elif status_byte == b'\x02':
        return 2  # Disengaged
    elif status_byte == b'\x03':
        return 3  # Error
    else:
        return -1  # Invalid status

def process_sensor_requests():
    sensor_status = []

    for request in sensor_requests:
        if request.startswith('FA'):
            uart1.write(bytes.fromhex(request))
            time.sleep(0.1)
            response = uart1.read()
            if response and response[0:1] == b'\xF5':
                sensor_status.append(calculate_sensor_status(response))
            else:
                sensor_status.append(0)
    # Construct message
    total_sensors = len(sensor_requests)
    total_engaged = sensor_status.count(1)
    total_disengaged = sensor_status.count(2)
    total_errors = sensor_status.count(3)
    total_vacancy = total_disengaged
    message = bytearray([0xAA, int.from_bytes(zone_id, "little"), total_sensors] + sensor_status + [total_engaged, total_disengaged, total_vacancy, total_errors])
    
    # Calculate CRC-16
    crc = crc16(message)
    message.append(crc >> 8)  # Append high byte of CRC
    message.append(crc & 0xFF)  # Append low byte of CRC
    message.append(0x55)
    
    # Send message using ESP-NOW to Floor Controller
    esp_now.send(floor_controller_mac, message)
    
    # Display part
    slots_str = f'{total_vacancy:02d}'
    display_message = f'|C|1|4|1|28-0-#u{slots_str}|'
    print(display_message)
    
    # Send display message using ESP-NOW to Display Controller
    esp_now.send(display_controller_mac, display_message.encode())

# Listen for commands from the floor controller
def on_receive_msg(peer, msg):
    if len(msg) == 5 and msg[0:1] == b'\xAA' and msg[4:5] == b'\x55':
        command_zone_id = msg[1:2]
        if command_zone_id == zone_id:
            process_sensor_requests()

esp_now.on_recv(on_receive_msg)

while True:
    time.sleep(1)

//EXAMPLE-2 zone1 controller which receive the request command through the floor controller through wireless using espnow. and when it recive the request then it send the request to the sensors and capture the response from then. and after that 
// it will send the display data and the floor data worelessly using espnow
from machine import UART, Pin
import time
import espnow
import network

# Initialize UARTs
uart1 = UART(1, baudrate=9600, tx=Pin(16), rx=Pin(17))

# Initialize ESP-NOW
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
esp_now = espnow.ESPNow()
esp_now.init()

# Register peers (Floor Controller and Display Controller MAC addresses)
floor_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the floor controller
display_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the display controller
esp_now.add_peer(floor_controller_mac)
esp_now.add_peer(display_controller_mac)

sensor_requests = ['FA0101F9', 'FA0201FA', 'FA0301FB']
zone_id = b'\x02'  # Change this for each zone controller (e.g., b'\x02' for zone 2)

def crc16(data: bytearray) -> int:
    crc = 0x0000
    for byte in data:
        crc ^= byte << 8
        for _ in range(8):
            if (crc & 0x8000) != 0:
                crc = (crc << 1) ^ 0x1021
            else:
                crc = crc << 1
        crc &= 0xFFFF  # Ensure CRC remains 16-bit
    return crc

def calculate_sensor_status(response):
    status_byte = response[2:3]
    if status_byte == b'\x01':
        return 1  # Engaged
    elif status_byte == b'\x02':
        return 2  # Disengaged
    elif status_byte == b'\x03':
        return 3  # Error
    else:
        return -1  # Invalid status

def process_sensor_requests():
    sensor_status = []

    for request in sensor_requests:
        if request.startswith('FA'):
            uart1.write(bytes.fromhex(request))
            time.sleep(0.1)
            response = uart1.read()
            if response and response[0:1] == b'\xF5':
                sensor_status.append(calculate_sensor_status(response))
            else:
                sensor_status.append(0)
    # Construct message
    total_sensors = len(sensor_requests)
    total_engaged = sensor_status.count(1)
    total_disengaged = sensor_status.count(2)
    total_errors = sensor_status.count(3)
    total_vacancy = total_disengaged
    message = bytearray([0xAA, int.from_bytes(zone_id, "little"), total_sensors] + sensor_status + [total_engaged, total_disengaged, total_vacancy, total_errors])
    
    # Calculate CRC-16
    crc = crc16(message)
    message.append(crc >> 8)  # Append high byte of CRC
    message.append(crc & 0xFF)  # Append low byte of CRC
    message.append(0x55)
    
    # Send message using ESP-NOW to Floor Controller
    esp_now.send(floor_controller_mac, message)
    
    # Display part
    slots_str = f'{total_vacancy:02d}'
    display_message = f'|C|1|4|1|28-0-#u{slots_str}|'
    print(display_message)
    
    # Send display message using ESP-NOW to Display Controller
    esp_now.send(display_controller_mac, display_message.encode())

# Listen for commands from the floor controller
def on_receive_msg(peer, msg):
    if len(msg) == 5 and msg[0:1] == b'\xAA' and msg[4:5] == b'\x55':
        command_zone_id = msg[1:2]
        if command_zone_id == zone_id:
            process_sensor_requests()

esp_now.on_recv(on_receive_msg)

while True:
    time.sleep(1)

//EXAMPLE-3 zone1 controller which receive the request command through the floor controller through wireless using espnow. and when it recive the request then it send the request to the sensors and capture the response from then. and after that 
// it will send the display data and the floor data worelessly using espnow
from machine import UART, Pin
import time
import espnow
import network

# Initialize UARTs
uart1 = UART(1, baudrate=9600, tx=Pin(16), rx=Pin(17))

# Initialize ESP-NOW
wlan = network.WLAN(network.STA_IF)
wlan.active(True)
esp_now = espnow.ESPNow()
esp_now.init()

# Register peers (Floor Controller and Display Controller MAC addresses)
floor_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the floor controller
display_controller_mac = b'\xFF\xFF\xFF\xFF\xFF\xFF'  # Replace with actual MAC address of the display controller
esp_now.add_peer(floor_controller_mac)
esp_now.add_peer(display_controller_mac)

sensor_requests = ['FA0101F9', 'FA0201FA', 'FA0301FB']
zone_id = b'\x03'  # Change this for each zone controller (e.g., b'\x02' for zone 2)

def crc16(data: bytearray) -> int:
    crc = 0x0000
    for byte in data:
        crc ^= byte << 8
        for _ in range(8):
            if (crc & 0x8000) != 0:
                crc = (crc << 1) ^ 0x1021
            else:
                crc = crc << 1
        crc &= 0xFFFF  # Ensure CRC remains 16-bit
    return crc

def calculate_sensor_status(response):
    status_byte = response[2:3]
    if status_byte == b'\x01':
        return 1  # Engaged
    elif status_byte == b'\x02':
        return 2  # Disengaged
    elif status_byte == b'\x03':
        return 3  # Error
    else:
        return -1  # Invalid status

def process_sensor_requests():
    sensor_status = []

    for request in sensor_requests:
        if request.startswith('FA'):
            uart1.write(bytes.fromhex(request))
            time.sleep(0.1)
            response = uart1.read()
            if response and response[0:1] == b'\xF5':
                sensor_status.append(calculate_sensor_status(response))
            else:
                sensor_status.append(0)
    # Construct message
    total_sensors = len(sensor_requests)
    total_engaged = sensor_status.count(1)
    total_disengaged = sensor_status.count(2)
    total_errors = sensor_status.count(3)
    total_vacancy = total_disengaged
    message = bytearray([0xAA, int.from_bytes(zone_id, "little"), total_sensors] + sensor_status + [total_engaged, total_disengaged, total_vacancy, total_errors])
    
    # Calculate CRC-16
    crc = crc16(message)
    message.append(crc >> 8)  # Append high byte of CRC
    message.append(crc & 0xFF)  # Append low byte of CRC
    message.append(0x55)
    
    # Send message using ESP-NOW to Floor Controller
    esp_now.send(floor_controller_mac, message)
    
    # Display part
    slots_str = f'{total_vacancy:02d}'
    display_message = f'|C|1|4|1|28-0-#u{slots_str}|'
    print(display_message)
    
    # Send display message using ESP-NOW to Display Controller
    esp_now.send(display_controller_mac, display_message.encode())

# Listen for commands from the floor controller
def on_receive_msg(peer, msg):
    if len(msg) == 5 and msg[0:1] == b'\xAA' and msg[4:5] == b'\x55':
        command_zone_id = msg[1:2]
        if command_zone_id == zone_id:
            process_sensor_requests()

esp_now.on_recv(on_receive_msg)

while True:
    time.sleep(1)
